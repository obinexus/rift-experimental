#!/bin/bash
#
# RIFT pkg-config Integration Framework
# =====================================
#
# Systematic pkg-config configuration for RIFT stages 0-6
# Enables external tool integration with librift-N.a static libraries
# AEGIS Compliant - Waterfall Methodology Implementation
#
# Technical Lead: Nnamdi Michael Okpala
# Framework: OBINexus Computing - Computing from the Heart
#

set -euo pipefail

# Framework Configuration
readonly SCRIPT_VERSION="1.0.0"
readonly AEGIS_COMPLIANCE="ENABLED"
readonly PKG_CONFIG_VERSION="0.29.2"

# Project Structure
readonly PROJECT_ROOT="$(pwd)"
readonly PKG_CONFIG_DIR="${PROJECT_ROOT}/rift/pkgconfig"
readonly CMAKE_TEMPLATES_DIR="${PKG_CONFIG_DIR}/templates"
readonly INSTALL_PC_DIR="/usr/local/lib/pkgconfig"

# Stage Configuration Matrix
declare -A RIFT_STAGES=(
    ["0"]="tokenizer:Tokenizer:RIFT_TOKENIZER"
    ["1"]="parser:Parser:RIFT_PARSER" 
    ["2"]="semantic:Semantic_Analyzer:RIFT_SEMANTIC"
    ["3"]="validator:Validator:RIFT_VALIDATOR"
    ["4"]="bytecode:Bytecode_Generator:RIFT_BYTECODE"
    ["5"]="verifier:Verifier:RIFT_VERIFIER"
    ["6"]="emitter:Emitter:RIFT_EMITTER"
)

# ANSI Colors for Technical Output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly NC='\033[0m'

# Technical Logging Functions
log_technical() {
    echo -e "${BLUE}${BOLD}[TECHNICAL]${NC} $1"
}

log_aegis() {
    echo -e "${MAGENTA}${BOLD}[AEGIS]${NC} $1"
}

log_success() {
    echo -e "${GREEN}${BOLD}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}${BOLD}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}${BOLD}[ERROR]${NC} $1"
}

# Framework Initialization
initialize_pkgconfig_framework() {
    log_technical "Initializing RIFT pkg-config Integration Framework v${SCRIPT_VERSION}"
    log_aegis "AEGIS Compliance Mode: ${AEGIS_COMPLIANCE}"
    
    # Create directory structure
    mkdir -p "$PKG_CONFIG_DIR"
    mkdir -p "$CMAKE_TEMPLATES_DIR"
    mkdir -p "${PROJECT_ROOT}/rift/build/pkgconfig"
    
    log_success "pkg-config framework directories initialized"
}

# Generate Stage-Specific .pc.in Templates
generate_stage_pc_templates() {
    log_technical "Generating stage-specific .pc.in templates"
    
    for stage_id in "${!RIFT_STAGES[@]}"; do
        local stage_info="${RIFT_STAGES[$stage_id]}"
        local stage_name="$(echo "$stage_info" | cut -d: -f1)"
        local stage_desc="$(echo "$stage_info" | cut -d: -f2)"
        local stage_define="$(echo "$stage_info" | cut -d: -f3)"
        
        generate_pc_template "$stage_id" "$stage_name" "$stage_desc" "$stage_define"
    done
    
    log_success "All stage .pc.in templates generated"
}

# Generate Individual .pc.in Template
generate_pc_template() {
    local stage_id="$1"
    local stage_name="$2" 
    local stage_desc="$3"
    local stage_define="$4"
    
    local pc_template="${PKG_CONFIG_DIR}/rift-${stage_id}.pc.in"
    
    log_technical "Generating rift-${stage_id}.pc.in (${stage_desc})"
    
    cat > "$pc_template" << EOF
# RIFT Stage ${stage_id} pkg-config Template
# Generated by OBINexus Computing Framework
# RIFT is a Flexible Translator - Nnamdi Michael Okpala
# AEGIS Compliant Configuration

prefix=@CMAKE_INSTALL_PREFIX@
exec_prefix=\${prefix}
libdir=\${exec_prefix}/lib
includedir=\${prefix}/include
bindir=\${exec_prefix}/bin

# Stage-specific paths
stage_libdir=\${libdir}/rift/stage-${stage_id}
stage_includedir=\${includedir}/rift/core/stage-${stage_id}

Name: RIFT Stage ${stage_id} - ${stage_desc}
Description: RIFT ${stage_desc} Static Library (Stage ${stage_id})
URL: https://github.com/obinexus/rift
Version: @PROJECT_VERSION@
Requires: 
Conflicts:

# Library linkage
Libs: -L\${libdir} -lrift-${stage_id}_static
Libs.private: -lm -lpthread

# Compiler flags
Cflags: -I\${stage_includedir} -I\${includedir}/rift/core -D${stage_define}_ENABLED
EOF

    log_success "Template rift-${stage_id}.pc.in created"
}

# Generate CMake Integration Configuration
generate_cmake_pkgconfig_integration() {
    log_technical "Generating CMake pkg-config integration"
    
    local cmake_config="${CMAKE_TEMPLATES_DIR}/PkgConfigIntegration.cmake"
    
    cat > "$cmake_config" << 'EOF'
# RIFT pkg-config Integration for CMake
# AEGIS Compliant Build Configuration
# OBINexus Computing Framework

# Function to configure pkg-config for a RIFT stage
function(configure_rift_stage_pkgconfig STAGE_ID STAGE_NAME)
    set(PC_TEMPLATE "${CMAKE_SOURCE_DIR}/rift/pkgconfig/rift-${STAGE_ID}.pc.in")
    set(PC_OUTPUT "${CMAKE_BINARY_DIR}/pkgconfig/rift-${STAGE_ID}.pc")
    
    # Ensure output directory exists
    file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}/pkgconfig")
    
    # Configure the .pc file
    configure_file("${PC_TEMPLATE}" "${PC_OUTPUT}" @ONLY)
    
    # Install the .pc file
    install(FILES "${PC_OUTPUT}"
            DESTINATION "${CMAKE_INSTALL_LIBDIR}/pkgconfig"
            COMPONENT Development)
    
    # Log configuration
    message(STATUS "RIFT Stage ${STAGE_ID}: pkg-config configured (${STAGE_NAME})")
endfunction()

# Function to configure all RIFT stages
function(configure_all_rift_stages)
    # Stage definitions matching the shell script
    set(RIFT_STAGE_0_NAME "tokenizer")
    set(RIFT_STAGE_1_NAME "parser")
    set(RIFT_STAGE_2_NAME "semantic")
    set(RIFT_STAGE_3_NAME "validator") 
    set(RIFT_STAGE_4_NAME "bytecode")
    set(RIFT_STAGE_5_NAME "verifier")
    set(RIFT_STAGE_6_NAME "emitter")
    
    # Configure each stage
    foreach(STAGE_NUM RANGE 0 6)
        configure_rift_stage_pkgconfig(${STAGE_NUM} ${RIFT_STAGE_${STAGE_NUM}_NAME})
    endforeach()
    
    message(STATUS "AEGIS Compliance: All RIFT stage pkg-config files configured")
endfunction()

# Validation function for pkg-config integration
function(validate_pkgconfig_installation)
    find_program(PKG_CONFIG_EXECUTABLE pkg-config)
    
    if(PKG_CONFIG_EXECUTABLE)
        message(STATUS "pkg-config found: ${PKG_CONFIG_EXECUTABLE}")
        
        # Get pkg-config version
        execute_process(
            COMMAND ${PKG_CONFIG_EXECUTABLE} --version
            OUTPUT_VARIABLE PKG_CONFIG_VERSION
            OUTPUT_STRIP_TRAILING_WHITESPACE
        )
        message(STATUS "pkg-config version: ${PKG_CONFIG_VERSION}")
        
        # Validate minimum version (0.29.0 or higher recommended)
        if(PKG_CONFIG_VERSION VERSION_LESS "0.29.0")
            message(WARNING "pkg-config version ${PKG_CONFIG_VERSION} may have compatibility issues. Recommend 0.29.0+")
        endif()
    else()
        message(WARNING "pkg-config not found. External library linking may be affected.")
    endif()
endfunction()
EOF

    log_success "CMake pkg-config integration configuration generated"
}

# Generate Root CMakeLists.txt Integration
generate_root_cmake_integration() {
    log_technical "Generating root CMakeLists.txt pkg-config integration"
    
    local cmake_snippet="${CMAKE_TEMPLATES_DIR}/RootCMakeIntegration.cmake"
    
    cat > "$cmake_snippet" << 'EOF'
# RIFT Root CMakeLists.txt pkg-config Integration Snippet
# Add this to your main CMakeLists.txt

# Include pkg-config integration
include(${CMAKE_SOURCE_DIR}/rift/pkgconfig/templates/PkgConfigIntegration.cmake)

# Validate pkg-config availability
validate_pkgconfig_installation()

# Configure pkg-config for all RIFT stages
configure_all_rift_stages()

# Set pkg-config path for development
set(ENV{PKG_CONFIG_PATH} "${CMAKE_BINARY_DIR}/pkgconfig:$ENV{PKG_CONFIG_PATH}")

# Create convenience target for pkg-config validation
add_custom_target(validate-pkgconfig
    COMMAND ${CMAKE_COMMAND} -E echo "Validating RIFT pkg-config installation..."
    COMMAND bash -c "for stage in {0..6}; do echo -n \"Stage \$stage: \"; pkg-config --exists rift-\$stage && echo \"✓ Found\" || echo \"✗ Missing\"; done"
    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
    COMMENT "Validating RIFT pkg-config files"
    VERBATIM
)
EOF

    log_success "Root CMake integration snippet generated"
}

# Generate Stage-Specific CMakeLists.txt Integration
generate_stage_cmake_integration() {
    log_technical "Generating stage-specific CMakeLists.txt integration templates"
    
    for stage_id in "${!RIFT_STAGES[@]}"; do
        local stage_info="${RIFT_STAGES[$stage_id]}"
        local stage_name="$(echo "$stage_info" | cut -d: -f1)"
        
        local cmake_stage="${CMAKE_TEMPLATES_DIR}/Stage${stage_id}CMakeIntegration.cmake"
        
        cat > "$cmake_stage" << EOF
# RIFT Stage ${stage_id} (${stage_name}) CMakeLists.txt Integration
# Add this to rift/rift-${stage_id}/CMakeLists.txt or equivalent

# Stage ${stage_id} Library Target
add_library(rift-${stage_id}_static STATIC
    src/core/${stage_name}.c
    # Add other source files as needed
)

# Set target properties
set_target_properties(rift-${stage_id}_static PROPERTIES
    OUTPUT_NAME "rift-${stage_id}"
    ARCHIVE_OUTPUT_DIRECTORY "\${CMAKE_BINARY_DIR}/lib"
    POSITION_INDEPENDENT_CODE ON
)

# Include directories
target_include_directories(rift-${stage_id}_static PUBLIC
    \$<BUILD_INTERFACE:\${CMAKE_CURRENT_SOURCE_DIR}/include>
    \$<INSTALL_INTERFACE:include/rift/core/stage-${stage_id}>
)

# Compiler definitions for AEGIS compliance
target_compile_definitions(rift-${stage_id}_static PUBLIC
    RIFT_STAGE_${stage_id}_ENABLED=1
    AEGIS_COMPLIANCE_ENABLED=1
)

# Install library
install(TARGETS rift-${stage_id}_static
    EXPORT RiftStage${stage_id}Targets
    ARCHIVE DESTINATION \${CMAKE_INSTALL_LIBDIR}
    LIBRARY DESTINATION \${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION \${CMAKE_INSTALL_BINDIR}
)

# Install headers
install(DIRECTORY include/
    DESTINATION \${CMAKE_INSTALL_INCLUDEDIR}/rift/core/stage-${stage_id}
    FILES_MATCHING PATTERN "*.h"
)
EOF

        log_success "Stage ${stage_id} CMake integration template generated"
    done
}

# Generate Validation Scripts
generate_validation_scripts() {
    log_technical "Generating pkg-config validation scripts"
    
    local validation_script="${PKG_CONFIG_DIR}/validate-pkgconfig.sh"
    
    cat > "$validation_script" << 'EOF'
#!/bin/bash
# RIFT pkg-config Validation Script
# AEGIS Compliant Testing Framework

set -euo pipefail

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m'

echo "🔍 RIFT pkg-config Validation Suite"
echo "===================================="

# Check pkg-config availability
if ! command -v pkg-config >/dev/null 2>&1; then
    echo -e "${RED}✗ pkg-config not found${NC}"
    exit 1
fi

echo -e "${GREEN}✓ pkg-config available: $(pkg-config --version)${NC}"

# Check each RIFT stage
failed_stages=()
for stage in {0..6}; do
    echo -n "Testing rift-${stage}.pc: "
    if pkg-config --exists "rift-${stage}" 2>/dev/null; then
        version=$(pkg-config --modversion "rift-${stage}")
        cflags=$(pkg-config --cflags "rift-${stage}")
        libs=$(pkg-config --libs "rift-${stage}")
        echo -e "${GREEN}✓ Found (v${version})${NC}"
        echo "  CFLAGS: ${cflags}"
        echo "  LIBS: ${libs}"
    else
        echo -e "${RED}✗ Missing${NC}"
        failed_stages+=("${stage}")
    fi
    echo
done

# Test unified linking
echo "Testing unified linking:"
if pkg-config --exists $(printf "rift-%d " {0..6}) 2>/dev/null; then
    unified_cflags=$(pkg-config --cflags $(printf "rift-%d " {0..6}))
    unified_libs=$(pkg-config --libs $(printf "rift-%d " {0..6}))
    echo -e "${GREEN}✓ Unified linking available${NC}"
    echo "  Combined CFLAGS: ${unified_cflags}"
    echo "  Combined LIBS: ${unified_libs}"
else
    echo -e "${YELLOW}⚠ Unified linking not available${NC}"
fi

# Summary
if [ ${#failed_stages[@]} -eq 0 ]; then
    echo -e "\n${GREEN}✓ All RIFT pkg-config files validated successfully${NC}"
    exit 0
else
    echo -e "\n${RED}✗ Failed stages: ${failed_stages[*]}${NC}"
    exit 1
fi
EOF

    chmod +x "$validation_script"
    log_success "pkg-config validation script generated"
}

# Generate External Usage Examples
generate_usage_examples() {
    log_technical "Generating external usage examples"
    
    local examples_dir="${PKG_CONFIG_DIR}/examples"
    mkdir -p "$examples_dir"
    
    # Example 1: Single stage usage
    cat > "${examples_dir}/single-stage-example.c" << 'EOF'
/*
 * RIFT Single Stage Usage Example
 * Demonstrates linking against rift-0 (tokenizer) using pkg-config
 * 
 * Compile with:
 * gcc -o tokenizer-example single-stage-example.c $(pkg-config --cflags --libs rift-0)
 */

#include <stdio.h>
#include <stdlib.h>

// RIFT Stage 0 headers (resolved via pkg-config)
#ifdef RIFT_STAGE_0_ENABLED
#include "tokenizer.h"
#endif

int main(int argc, char* argv[]) {
    printf("RIFT Single Stage Usage Example\n");
    printf("================================\n");
    
    if (argc < 2) {
        printf("Usage: %s <input-text>\n", argv[0]);
        return 1;
    }
    
    const char* input = argv[1];
    printf("Input: %s\n", input);
    
#ifdef RIFT_STAGE_0_ENABLED
    // Use RIFT tokenizer functionality
    char* tokenized_output = NULL;
    RiftResult result = rift_stage0_process(input, &tokenized_output);
    
    if (result == RIFT_SUCCESS && tokenized_output) {
        printf("Tokenized Output: %s\n", tokenized_output);
        free(tokenized_output);
    } else {
        printf("Tokenization failed\n");
        return 1;
    }
#else
    printf("RIFT Stage 0 not available\n");
#endif
    
    return 0;
}
EOF

    # Example 2: Multi-stage pipeline
    cat > "${examples_dir}/pipeline-example.c" << 'EOF'
/*
 * RIFT Pipeline Usage Example
 * Demonstrates full pipeline using all stages via pkg-config
 * 
 * Compile with:
 * gcc -o pipeline-example pipeline-example.c $(pkg-config --cflags --libs rift-0 rift-1 rift-2 rift-3 rift-4 rift-5 rift-6)
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Include headers for all stages (resolved via pkg-config)
#ifdef RIFT_STAGE_0_ENABLED
#include "tokenizer.h"
#endif
#ifdef RIFT_STAGE_1_ENABLED  
#include "parser.h"
#endif
// ... additional stage includes as needed

int main(int argc, char* argv[]) {
    printf("RIFT Full Pipeline Example\n");
    printf("==========================\n");
    
    if (argc < 2) {
        printf("Usage: %s <input-text>\n", argv[0]);
        return 1;
    }
    
    const char* input = argv[1];
    char* stage_output = strdup(input);
    
    printf("Processing through RIFT pipeline...\n");
    printf("Input: %s\n", input);
    
    // Stage 0: Tokenizer
#ifdef RIFT_STAGE_0_ENABLED
    char* tokenized = NULL;
    if (rift_stage0_process(stage_output, &tokenized) == RIFT_SUCCESS) {
        printf("Stage 0 (Tokenizer): %s\n", tokenized);
        free(stage_output);
        stage_output = tokenized;
    }
#endif
    
    // Stage 1: Parser  
#ifdef RIFT_STAGE_1_ENABLED
    char* parsed = NULL;
    if (rift_stage1_process(stage_output, &parsed) == RIFT_SUCCESS) {
        printf("Stage 1 (Parser): %s\n", parsed);
        free(stage_output);
        stage_output = parsed;
    }
#endif
    
    // Continue with remaining stages...
    
    printf("Final Output: %s\n", stage_output);
    free(stage_output);
    
    return 0;
}
EOF

    # Example 3: Makefile using pkg-config
    cat > "${examples_dir}/Makefile.example" << 'EOF'
# RIFT External Project Makefile Example
# Demonstrates pkg-config integration for external projects

CC = gcc
CFLAGS = -Wall -Wextra -std=c11
PKG_CONFIG = pkg-config

# RIFT packages
RIFT_STAGES = rift-0 rift-1 rift-2 rift-3 rift-4 rift-5 rift-6
RIFT_SINGLE = rift-0

# Targets
all: single-stage-example pipeline-example

single-stage-example: single-stage-example.c
	$(CC) $(CFLAGS) -o $@ $< $(shell $(PKG_CONFIG) --cflags --libs $(RIFT_SINGLE))

pipeline-example: pipeline-example.c  
	$(CC) $(CFLAGS) -o $@ $< $(shell $(PKG_CONFIG) --cflags --libs $(RIFT_STAGES))

clean:
	rm -f single-stage-example pipeline-example

test: all
	@echo "Testing single-stage example..."
	./single-stage-example "test input"
	@echo "Testing pipeline example..."
	./pipeline-example "test input"

.PHONY: all clean test
EOF

    log_success "External usage examples generated"
}

# Main Execution Framework
main() {
    echo -e "${CYAN}${BOLD}"
    echo "  ██████╗ ██╗███████╗████████╗"
    echo "  ██╔══██╗██║██╔════╝╚══██╔══╝"
    echo "  ██████╔╝██║█████╗     ██║   "
    echo "  ██╔══██╗██║██╔══╝     ██║   "
    echo "  ██║  ██║██║██║        ██║   "
    echo "  ╚═╝  ╚═╝╚═╝╚═╝        ╚═╝   "
    echo -e "${NC}"
    echo -e "${BLUE}${BOLD}RIFT pkg-config Integration Framework${NC}"
    echo -e "${MAGENTA}OBINexus Computing - Computing from the Heart${NC}"
    echo ""
    
    # Framework execution sequence
    initialize_pkgconfig_framework
    generate_stage_pc_templates
    generate_cmake_pkgconfig_integration
    generate_root_cmake_integration
    generate_stage_cmake_integration
    generate_validation_scripts
    generate_usage_examples
    
    # Summary
    echo ""
    echo -e "${GREEN}${BOLD}🎉 RIFT pkg-config Integration Framework Complete${NC}"
    echo ""
    echo -e "${YELLOW}Next Steps:${NC}"
    echo "1. Integrate CMake templates into your build configuration"
    echo "2. Run 'cmake -B build && cmake --build build'"
    echo "3. Execute 'make install' to deploy .pc files"
    echo "4. Validate with './rift/pkgconfig/validate-pkgconfig.sh'"
    echo "5. Test external linking with examples in rift/pkgconfig/examples/"
    echo ""
    echo -e "${CYAN}External Usage:${NC}"
    echo "gcc -o app app.c \$(pkg-config --cflags --libs rift-0)"
    echo "gcc -o pipeline app.c \$(pkg-config --cflags --libs rift-{0..6})"
    echo ""
    echo -e "${MAGENTA}AEGIS Compliance: ✓ Enabled${NC}"
    echo -e "${MAGENTA}Waterfall Methodology: ✓ Implementation Gate Ready${NC}"
}

# Execute framework
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
