# RIFT POC: AST-Aware Bytecode Generation with Zero Trust Governance

A systematic compilation pipeline implementing AST-Aware bytecode generation with cryptographic governance, QA-driven validation, and Sinphase architectural structuring.

## Architecture Overview

The RIFT (Rapid Iteration Framework Technology) POC implements a 5-stage compilation pipeline with Zero Trust cryptographic governance enforced at each stage transition.

### Pipeline Stages

| Stage | Directory | Function | Security Level |
|-------|-----------|----------|----------------|
| 0 | `rift-poc-stage-0` | Tokenization/Lexical Analysis | Standard |
| 1 | `rift-poc-stage-1` | Parsing/Grammar Analysis | Standard |
| 3 | `rift-poc-stage-3` | AST Generation/Contextualization | High |
| 4 | `rift-poc-stage-4` | Bytecode Generation | **Maximum** |
| 5 | `rift-poc-stage-5` | Program Output/Execution | **Maximum** |

### Source Organization

- **Current POC Source**: `rift-poc-nlink-project-1/` contains the working implementation
- **Stage Isolation**: Each `rift-poc-stage-N/` directory contains isolated components following Sinphase principles
- **Build Orchestration**: `nlink` → `polybuild` toolchain integration

## Core Technologies

### AEGIS (Automaton Engine for Generative Interpretation & Syntax)
- Regular expression automaton model for flexible syntax recognition
- Pattern-based transformation system
- Data-oriented parser with functional IR generation
- Unified compilation pipeline with semantic preservation

### Sinphase (Single-Pass Hierarchical Structuring)
- Cost-based architectural governance
- Hierarchical component isolation
- Single-pass compilation requirements
- Deterministic build behavior with acyclic dependency graphs

### Zero Trust Governance
- Cryptographic signing of all `.rift.N` artifacts
- Residual Trust enforcement - no artifact trusted without fresh verification
- RSA-4096 bit keys with SHA-256 signatures
- Fail-fast governance on any trust violation

## Build System Requirements

### Initialization
```bash
# Initialize Zero Trust cryptographic environment
make zero-trust-init

# Verify cryptographic key integrity
make verify-keys
```

### Development Workflow
```bash
# Validate all QA requirements and run test suites
make test

# Build with Zero Trust pipeline enforcement
make build

# Execute complete Zero Trust compilation pipeline
./scripts/rift-zero-trust-pipeline.sh <input.rift>
```

### Pipeline Execution
The Zero Trust pipeline processes `.rift` files through all stages:
1. **Stage 0→1**: Tokenization with cryptographic signing
2. **Stage 1→3**: Parsing with signature verification + new signing
3. **Stage 3→4**: AST transformation with mandatory verification
4. **Stage 4→5**: Bytecode generation with maximum security enforcement
5. **Output**: Cryptographically attested program artifacts

## QA-Driven Architecture

### Required QA Components
Each stage directory must contain:

```
rift-poc-stage-N/
├── src/                     # Implementation
├── include/                 # Headers  
├── tests/
│   └── qa_mocks/           # QA artifact blocks (REQUIRED)
├── QA/
│   └── edge_case_registry.md # Edge case documentation
└── nlink/                   # Build orchestration
```

### QA Validation Framework
- **Edge Case Registry**: `QA/edge_case_registry.md` documents boundary conditions
- **QA Artifact Blocks**: `tests/qa_mocks/` contains validation implementations
- **Automated Testing**: All stages must pass `make test` validation
- **Boundary Analysis**: Comprehensive edge case detection and validation

### QA Integration Points
- **Memory Governance**: Token lifecycle validation with anti-reversion protection
- **Entropy Validation**: Shannon entropy calculation with context-aware validation
- **Stage Transitions**: Progressive validation with security scaling
- **Cryptographic Boundaries**: Signature verification and key integrity validation

## Technical Specifications

### AST-Aware Bytecode Generation
- **Semantic Preservation**: AST lineage tracking throughout compilation
- **Policy Attachment**: Formal architectural validation
- **IRP Transformation**: Intermediate Representation Processing with optimization
- **Dual Post-Processing**: Multiple output formats (ASM/AXC)

### Cryptographic Implementation
```bash
# Key locations (generated by make zero-trust-init)
keys/rift_signing_key.pem     # Private key (600 permissions)
keys/rift_signing_pub.pem     # Public key (distributable)

# Artifact signing pattern
input.rift → input.rift.0 + input.rift.0.sig
input.rift.0 → input.rift.1 + input.rift.1.sig
# ... continuing through all stages
```

### Cost-Based Governance
Dynamic cost evaluation triggers architectural reorganization:

```
Cost = Σ(metric_i × weight_i) + circular_penalty + temporal_pressure

Metrics: include_depth, function_calls, external_deps, complexity, link_deps
Threshold: 0.6 triggers isolation protocol
```

## Directory Structure Compliance

### Sinphase Enforcement
- **Acyclic Dependencies**: All component relationships must remain acyclic
- **Bounded Complexity**: Cost functions limit coupling within measurable thresholds  
- **Single-Pass Compilation**: Deterministic compilation order required
- **Hierarchical Isolation**: Components maintain clear boundaries through governance contracts

### Build System Integration
- **nlink Orchestration**: Package and dependency management
- **polybuild Integration**: Multi-stage build coordination
- **Independent Compilation**: Each stage compiles independently
- **Explicit Dependencies**: No hidden coupling through transitive dependencies

## Validation Requirements

### Mandatory Checks
1. **Cryptographic Integrity**: All signatures must verify
2. **QA Artifact Presence**: `tests/qa_mocks/` must exist and contain valid QA blocks
3. **Build Success**: `make build` must complete without errors
4. **Test Validation**: `make test` must pass all validation suites
5. **Zero Trust Compliance**: All artifacts must be cryptographically signed

### Stage Transition Validation
- **Signature Verification**: Previous stage artifacts verified before processing
- **Entropy Validation**: Context-aware entropy analysis at each transition
- **Memory Governance**: Token lifecycle validation with governance contracts
- **Anti-Reversion**: Protection against unauthorized rollback attempts

## Implementation Status

### Current State
- **POC Source**: Active development in `rift-poc-nlink-project-1/`
- **Stage Isolation**: Individual stage directories established
- **Zero Trust Pipeline**: Cryptographic governance implemented
- **QA Framework**: Edge case validation system operational
- **Build System**: nlink + polybuild integration functional

### Compliance Status
- ✅ Zero Trust cryptographic signing implemented
- ✅ QA-driven architecture with edge case validation
- ✅ Sinphase directory structuring enforced
- ✅ AEGIS pattern-based transformation system
- ✅ AST-Aware semantic preservation pipeline
- ✅ Cost-based governance checkpoints operational

## Technical Dependencies

### Core Requirements
- **Cryptographic Libraries**: RSA-4096, SHA-256 implementation
- **Build Tools**: make, nlink, polybuild toolchain
- **QA Framework**: Edge case validation and boundary testing
- **Governance Engine**: Cost calculation and threshold enforcement

### Integration Points
- **AEGIS Engine**: Pattern recognition and transformation
- **Sinphase Validator**: Architectural compliance checking  
- **Zero Trust Pipeline**: Cryptographic verification and signing
- **Memory Governance**: Token lifecycle and anti-reversion protection

---

**Technical Implementation**: OBINexus Computing methodology with formal verification and cryptographic attestation.

**Build Verification**: All components must pass cryptographic validation and QA compliance checks before deployment.